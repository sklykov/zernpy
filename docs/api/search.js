window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "zernpy.zernikepol", "modulename": "zernpy.zernikepol", "kind": "module", "doc": "<p>Main script with the class definition for accessing Zernike polynomial initialization, calculation and plotting.</p>\n\n<p>Also, provides a few functions useful for fitting set of Zernike polynomials to an image with phases.</p>\n\n<p>@author: Sergei Klykov, @year: 2023 </p>\n\n<p>@licence: MIT</p>\n"}, {"fullname": "zernpy.zernikepol.ZernPol", "modulename": "zernpy.zernikepol", "qualname": "ZernPol", "kind": "class", "doc": "<p>Define the Zernike polynomial class and associated calculation methods.</p>\n"}, {"fullname": "zernpy.zernikepol.ZernPol.__init__", "modulename": "zernpy.zernikepol", "qualname": "ZernPol.__init__", "kind": "function", "doc": "<p>Initialize of the class for Zernike polynomial definition as the object.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><p><strong>**kwargs</strong> (orders or index for Zernike polynomial initialization expected as key=value pairs):\nAcceptable variants for key=value pairs arguments: </p>\n\n<p>1) n=int, m=int with alternatives: \"radial_order\" for n; \"l\", \"azimuthal_order\", \"angular_frequency\" for m; </p>\n\n<p>2) osa_index=int with alternatives: \"osa\", \"ansi_index\", \"ansi\"; </p>\n\n<p>3) noll_index=int with alternative \"noll\"; </p>\n\n<p>4) fringe_index=int with alternative \"fringe\"</p></li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: Raised if the specified orders (m, n) or index (OSA, Noll...) have inconsistencies like: </li>\n</ul>\n\n<p>for specified orders:\n1) m &lt; 0 or n &lt; 0; 2) m or n is not int; 3) (self.__n - abs(self.__m)) % 2 == 0; </p>\n\n<p>4) if n &gt; 54 - because the polynomials with higher orders are meaningless due to very slow calculations; </p>\n\n<p>for indices - see the raised error message.</p>\n\n<h6 id=\"references\">References</h6>\n\n<p>[1] Wiki article: <a href=\"https://en.wikipedia.org/wiki/Zernike_polynomials\">https://en.wikipedia.org/wiki/Zernike_polynomials</a> </p>\n\n<p>[2] Shakibaei B.H., Paramesran R. \"Recursive formula to compute Zernike radial polynomials\" (2013) </p>\n\n<p>[3] Lakshminarayanan V., Fleck A. \"Zernike polynomials: a guide\" (2011) </p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>ZernPol class instance.</strong></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "zernpy.zernikepol.ZernPol.get_indices", "modulename": "zernpy.zernikepol", "qualname": "ZernPol.get_indices", "kind": "function", "doc": "<p>Return the tuple with following orders: ((m, n), OSA index, Noll index, Fringe index).</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tuple</strong>: with elements: (tuple (azimuthal (m), radial (n)) orders, OSA index, Noll index, Fringe index) </li>\n</ul>\n\n<p>All indices are integers.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.ZernPol.get_mn_orders", "modulename": "zernpy.zernikepol", "qualname": "ZernPol.get_mn_orders", "kind": "function", "doc": "<p>Return tuple with the (azimuthal, radial) orders, i.e. return (m, n).</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tuple</strong>: with the (azimuthal, radial) orders for the initialized Zernike polynomial.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.ZernPol.get_polynomial_name", "modulename": "zernpy.zernikepol", "qualname": "ZernPol.get_polynomial_name", "kind": "function", "doc": "<p>Return string with the conventional name (see references for details) of polynomial up to 7th order.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>short</strong> (bool, optional):\nIf True, this method returns shortened name. The default is False.</li>\n</ul>\n\n<h6 id=\"references\">References</h6>\n\n<p>[1] Up to 4th order: Wiki article: <a href=\"https://en.wikipedia.org/wiki/Zernike_polynomials\">https://en.wikipedia.org/wiki/Zernike_polynomials</a> </p>\n\n<p>[2] 5th order names: from the website <a href=\"https://www.telescope-optics.net/monochromatic_eye_aberrations.htm\">https://www.telescope-optics.net/monochromatic_eye_aberrations.htm</a> </p>\n\n<p>6th order - 7th order: my guess about the naming </p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: Name of the initialized polynomial.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">short</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.ZernPol.polynomial_value", "modulename": "zernpy.zernikepol", "qualname": "ZernPol.polynomial_value", "kind": "function", "doc": "<p>Calculate Zernike polynomial value(-s) within the unit circle.</p>\n\n<p>Calculation up to 10th order of Zernike function performed by exact equations from Ref.[2],\nafter - using the recurrence equations taken from the Ref.[1], using shortcut of storing\ncoefficients for each power of radius (coefficient*R^n) </p>\n\n<p>Surprisingly, the exact equation for polynomials are just pretty fast to use them directly, without\nany need to use the recurrence equations. It can be used by providing the flag as the input parameter. </p>\n\n<p>However, after ~ the 46th radial order due to the high integer values involved in the exact equation\n(factorials) producing ambiguous results (failed simple check that radial polynomial &lt;= 1.0),\nonly iterative equations (which along with increasing order become time-consuming and slow)\ncould be used. The 40th radial order as the limit for usage of the exact equation is selected due to\nfound increasing after this order discrepancy between results of recursive and factorial formulas.</p>\n\n<h6 id=\"references\">References</h6>\n\n<p>[1] Shakibaei B.H., Paramesran R. \"Recursive formula to compute Zernike radial polynomials\" (2013) </p>\n\n<p>[2] Lakshminarayanan V., Fleck A. \"Zernike polynomials: a guide\" (2011) </p>\n\n<p>[3] Andersen T. B. \"Efficient and robust recurrence relations for the Zernike\ncircle polynomials and their derivatives in Cartesian coordinates\" (2018) </p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>r</strong> (float or numpy.ndarray):\nRadius (radii) from unit circle or the range [0.0, 1.0], float / array, for which the polynomial is calculated.</li>\n<li><strong>theta</strong> (float or numpy.ndarray):\nTheta - angle in radians from the range [0, 2*pi], float or array, for which the polynomial is calculated.\nNote that the theta counting is counterclockwise, as it is default for the matplotlib library.</li>\n<li><strong>use_exact_eq</strong> (bool, optional):\nFlag for using the exact equation with factorials. The default is False.\nNote about the limit for usage of the exact equation - up to 40th radial order (n).</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: Check the Error stack trace for reasons of raising, most probably input parameters aren't acceptable.</li>\n<li><strong>Warning</strong>: If the theta angles lie outside the range [0, 2*pi] (entire period).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>float or numpy.ndarray</strong>: Calculated polynomial values on provided float values / arrays.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">r</span>, </span><span class=\"param\"><span class=\"n\">theta</span>, </span><span class=\"param\"><span class=\"n\">use_exact_eq</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.ZernPol.radial", "modulename": "zernpy.zernikepol", "qualname": "ZernPol.radial", "kind": "function", "doc": "<p>Calculate R(m, n) - radial Zernike function value(-s) within the unit circle.</p>\n\n<p>Calculation up to 10th order of Zernike function performed by exact equations from Ref.[2],\nafter - using the recurrence equations taken from the Ref.[1], using shortcut of storing\ncoefficients for each power of radius (coefficient*R^n) </p>\n\n<p>Surprisingly, the exact equation for polynomials are just pretty fast to use them directly, without\nany need to use the recurrence equations. It can be used by providing the flag as the input parameter. </p>\n\n<p>However, after ~ the 46th radial order due to the high integer values involved in the exact equation\n(factorials) producing ambiguous results (failed simple check that radial polynomial &lt;= 1.0),\nonly iterative equations (which along with increasing order become time-consuming and slow)\ncould be used. The 40th radial order as the limit for usage of the exact equation is selected due to\nfound increasing after this order discrepancy between results of recursive and factorial formulas.</p>\n\n<h6 id=\"references\">References</h6>\n\n<p>[1] Shakibaei B.H., Paramesran R. \"Recursive formula to compute Zernike radial polynomials\" (2013) </p>\n\n<p>[2] Lakshminarayanan V., Fleck A. \"Zernike polynomials: a guide\" (2011) </p>\n\n<p>[3] Andersen T. B. \"Efficient and robust recurrence relations for the Zernike\ncircle polynomials and their derivatives in Cartesian coordinates\" (2018) </p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>r</strong> (float or numpy.ndarray):\nRadius (radii) from unit circle or the range [0.0, 1.0], float / array, for which the function is calculated.</li>\n<li><strong>use_exact_eq</strong> (bool, optional):\nFlag for using the exact equation with factorials. The default is False.\nNote about the limit for usage of the exact equation - up to 40th radial order (n).</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: The probable reasons: radius (radii) doesn't belong to a unit circle, input type isn't acceptable.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>float or numpy.ndarray</strong>: Calculated Zernike radial function value(-s) on provided float values / arrays of radiuses.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">r</span>, </span><span class=\"param\"><span class=\"n\">use_exact_eq</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.ZernPol.triangular", "modulename": "zernpy.zernikepol", "qualname": "ZernPol.triangular", "kind": "function", "doc": "<p>Calculate triangular Zernike function value(-s) within the unit circle.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>theta</strong> (float or numpy.ndarray):\nTheta - angle in radians from the range [0, 2*pi], float or array, for which the polynomial is calculated.\nNote that the theta counting is counterclockwise, as it is default for the matplotlib library.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: Most probably, raised if the conversion to float number is failed. </li>\n</ul>\n\n<p>It happens when input parameter is not float, numpy.ndarray, list or tuple.</p>\n\n<ul>\n<li><strong>Warning</strong>: If the theta angles lie outside the range [0, 2*pi] (entire period).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>float or numpy.ndarray</strong>: Calculated value(-s) of Zernike triangular function on provided angle.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">theta</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.ZernPol.radial_dr", "modulename": "zernpy.zernikepol", "qualname": "ZernPol.radial_dr", "kind": "function", "doc": "<p>Calculate derivative of radial Zernike polynomial value(-s) within the unit circle.</p>\n\n<p>Calculation up to 10th order of Zernike polynomials performed by exact equations,\nafter - using the recurrence equations, using shortcut of storing\ncoefficients for each power of radius (coefficient*R^n) </p>\n\n<p>The input flag use_exact_eq allows using the exact equation with factorials.\nBut note that after 38th radial order the usage of the exact equation is forbidden, because\nafter ~ the 44th radial order due to the high integer values associated with factorials and power\nvalues produced by derivatives leading to ambiguous results, only iterative equations\n(which along with increasing order become time-consuming and slow) could be used. The 38th radial order\nas the limit for usage of the exact equation is selected due to found increasing after this order\ndiscrepancy between results of recursive and factorial formulas.</p>\n\n<h6 id=\"references\">References</h6>\n\n<p>Same as for the method \"radial\" or \"polynomial value\"</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>r</strong> (float or numpy.ndarray):\nRadius (radii) from unit circle or the range [0.0, 1.0], float / array, for which the polynomial is calculated.</li>\n<li><strong>use_exact_eq</strong> (bool, optional):\nFlag for using the exact equation with factorials. The default is False.\nNote about the limit for usage of the exact equation - up to 38th radial order (n).</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: The probable reasons: radius (radii) doesn't belong to a unit circle, input type isn't acceptable.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>float or numpy.ndarray</strong>: Calculated derivative of Zernike radial function value(-s) on provided float values / arrays of radiuses.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">r</span>, </span><span class=\"param\"><span class=\"n\">use_exact_eq</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.ZernPol.triangular_dtheta", "modulename": "zernpy.zernikepol", "qualname": "ZernPol.triangular_dtheta", "kind": "function", "doc": "<p>Calculate derivative from triangular function on angle theta.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>theta</strong> (float or numpy.ndarray):\nTheta - angle in radians from the range [0, 2*pi], float or array, for which the function is calculated.\nNote that the theta counting is counterclockwise, as it is default for the matplotlib library.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: Most probably, raised if the conversion to float number is failed. </li>\n</ul>\n\n<p>It happens when input parameter is not float, numpy.ndarray, list or tuple.</p>\n\n<ul>\n<li><strong>Warning</strong>: If the theta angles lie outside the range [0, 2*pi] (entire period).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>float or numpy.ndarray</strong>: Calculated derivative value(-s) of Zernike triangular function on provided angle.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">theta</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.ZernPol.normf", "modulename": "zernpy.zernikepol", "qualname": "ZernPol.normf", "kind": "function", "doc": "<p>Calculate normalization factor for the Zernike polynomial calculated according to the Reference below.</p>\n\n<h6 id=\"references\">References</h6>\n\n<p>[1] Shakibaei B.H., Paramesran R. \"Recursive formula to compute Zernike radial polynomials\" (2013)</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>float</strong>: Normalization factor calculated according to the Reference.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.ZernPol.get_osa_index", "modulename": "zernpy.zernikepol", "qualname": "ZernPol.get_osa_index", "kind": "function", "doc": "<p>Calculate OSA / ANSI index from the 2 orders of Zernike polynomials.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>m</strong> (int):\nAzimuthal order (angular frequency).</li>\n<li><strong>n</strong> (int):\nRadial order.</li>\n</ul>\n\n<h6 id=\"references\">References</h6>\n\n<p>[1] Wiki article: <a href=\"https://en.wikipedia.org/wiki/Zernike_polynomials\">https://en.wikipedia.org/wiki/Zernike_polynomials</a></p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>int</strong>: OSA index according to [1].</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.ZernPol.get_noll_index", "modulename": "zernpy.zernikepol", "qualname": "ZernPol.get_noll_index", "kind": "function", "doc": "<p>Calculate Noll index from the 2 orders of Zernike polynomials.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>m</strong> (int):\nAzimuthal order (angular frequency).</li>\n<li><strong>n</strong> (int):\nRadial order.</li>\n</ul>\n\n<h6 id=\"references\">References</h6>\n\n<p>[1] Wiki article: <a href=\"https://en.wikipedia.org/wiki/Zernike_polynomials\">https://en.wikipedia.org/wiki/Zernike_polynomials</a></p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>int</strong>: Noll index.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.ZernPol.get_fringe_index", "modulename": "zernpy.zernikepol", "qualname": "ZernPol.get_fringe_index", "kind": "function", "doc": "<p>Calculate Fringe / University of Arizona index from the 2 orders of Zernike polynomials.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>m</strong> (int):\nAzimuthal order (angular frequency).</li>\n<li><strong>n</strong> (int):\nRadial order.</li>\n</ul>\n\n<h6 id=\"references\">References</h6>\n\n<p>[1] Wiki article: <a href=\"https://en.wikipedia.org/wiki/Zernike_polynomials\">https://en.wikipedia.org/wiki/Zernike_polynomials</a></p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>int</strong>: Fringe index.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">m</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.ZernPol.index2orders", "modulename": "zernpy.zernikepol", "qualname": "ZernPol.index2orders", "kind": "function", "doc": "<p>Return tuple as (azimuthal, radial) orders for the specified by osa_, noll_ or fringe_index input parameter.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>**kwargs</strong> (dict):\nRecognizable values: osa_index, noll_index, fringe_index.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tuple</strong>: (m, n) - contains azimuthal and radial orders as integers.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.ZernPol.osa2noll", "modulename": "zernpy.zernikepol", "qualname": "ZernPol.osa2noll", "kind": "function", "doc": "<p>Convert the OSA / ANSI index of a Zernike polynomial to the Noll index.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>osa_index</strong> (int):\nOSA / ANSI index with int type, it must be not less than 0.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If the index provided with not int type or index &lt; 0.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>int</strong>: Converted Noll index.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">osa_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.ZernPol.noll2osa", "modulename": "zernpy.zernikepol", "qualname": "ZernPol.noll2osa", "kind": "function", "doc": "<p>Convert the Noll index of a Zernike polynomial to the OSA / ANSI index.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>noll_index</strong> (int):\nThe Noll index with int type, it must be not less than 1.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If the index provided with not int type or index &lt; 1.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>int</strong>: Converted OSA / ANSI index.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">noll_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.ZernPol.osa2fringe", "modulename": "zernpy.zernikepol", "qualname": "ZernPol.osa2fringe", "kind": "function", "doc": "<p>Convert the OSA / ANSI index of a Zernike polynomial to the Fringe index.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>osa_index</strong> (int):\nOSA / ANSI index with int type, it must be not less than 0.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If the index provided with not int type or index &lt; 0.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>int</strong>: Converted Fringe index.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">osa_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.ZernPol.fringe2osa", "modulename": "zernpy.zernikepol", "qualname": "ZernPol.fringe2osa", "kind": "function", "doc": "<p>Convert the Fringe / Univ. of Arizona index of a Zernike polynomial to the OSA / ANSI index.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>fringe_index</strong> (int):\nThe noll index with int type, it must be not less than 1.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If the index provided with not int type or index &lt; 1.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>int</strong>: Converted OSA / ANSI index.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fringe_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.ZernPol.sum_zernikes", "modulename": "zernpy.zernikepol", "qualname": "ZernPol.sum_zernikes", "kind": "function", "doc": "<p>Calculate sum of Zernike polynomials with their amplitude coefficients (e.g., for plotting over a unit circle).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>coefficients</strong> (list):\nCoefficients of Zernike polynomials for summing.</li>\n<li><strong>polynomials</strong> (list):\nInitialized polynomials as class instances of ZernPol class specified in this module.</li>\n<li><strong>r</strong> (float or numpy.ndarray):\nRadius(-s) from a unit circle.</li>\n<li><strong>theta</strong> (float or numpy.ndarray):\nPolar angle(-s) from a unit circle.</li>\n<li><p><strong>get_surface</strong> (bool, optional):\nIf True, it forces to calculate 2D sum of polynomials based on r and theta (as a mesh of polar coordinates).\nThe default is False. </p>\n\n<p>Note that if r and theta provided as the numpy ndarrays with different shapes and this flag is False, then\nthe result of this method will raise ValueError (because r and theta shapes will be checked for equality).</p></li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>TypeError</strong>: If the input parameters aren't iterable (doesn't support len() function), this error will be raised.</li>\n<li><strong>ValueError</strong>: If the lengths of lists (tuples, numpy.ndarrays) aren't equal for coefficients and polynomials. </li>\n</ul>\n\n<p>Or if the list (tuple, numpy.ndarray vector, ...) with Zernike polynomials instances (ZernPol()).</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Sum of Zernike polynomials</strong>: Depending on the input values and parameter get_surface - can be: float, 1D or 2D numpy.ndarrays.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">coefficients</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">polynomials</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">r</span>,</span><span class=\"param\">\t<span class=\"n\">theta</span>,</span><span class=\"param\">\t<span class=\"n\">get_surface</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.ZernPol.gen_polar_coordinates", "modulename": "zernpy.zernikepol", "qualname": "ZernPol.gen_polar_coordinates", "kind": "function", "doc": "<p>Generate named tuple \"PolarVectors\" with R and Theta - vectors with polar coordinates for an entire unit circle.</p>\n\n<p>Note that R and Theta are generated as the numpy.ndarrays vectors (shape like (n elements, )). Their shapes are\ndefined by the specification of r_step and theta_rad_step parameters.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>r_step</strong> (float, optional):\nStep for generation the vector with radiuses for an entire unit circle. The default is 0.01.</li>\n<li><strong>theta_rad_step</strong> (float, optional):\nStep for generation the vector with theta angles for an entire unit circle. The default is (np.pi/240).</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If the r_step or theta_rad_step provided in the way, that vectors R and Theta cannot be generated.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>polar_vectors</strong>: namedtuple(\"PolarVectors\", \"R Theta\"), where R - vector with radiuses values [0.0, r_step, ... 1.0],\nTheta - vector with theta angles values [0.0, theta_rad_step, ... 2*pi].</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">r_step</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">theta_rad_step</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01309</span></span><span class=\"return-annotation\">) -> <span class=\"n\">zernpy</span><span class=\"o\">.</span><span class=\"n\">zernikepol</span><span class=\"o\">.</span><span class=\"n\">PolarVectors</span>:</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.ZernPol.plot_zernike_polynomial", "modulename": "zernpy.zernikepol", "qualname": "ZernPol.plot_zernike_polynomial", "kind": "function", "doc": "<p>Plot the provided Zernike polynomial (instance of ZernPol class) on the matplotlib figure.</p>\n\n<p>Note that the plotting function plt.show() creates the plot in non-interactive mode.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>polynomial</strong> (ZernPol):\nInstance of ZernPol class.</li>\n<li><strong>color_map</strong> (str, optional):\nColor map of the polar plot, recommended values: coolwarm, jet, turbo, rainbow. The default is \"coolwarm\".</li>\n<li><strong>show_title</strong> (bool, optional):\nToggle for showing the name of polynomial on the plot or not.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None.</strong></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">polynomial</span>, </span><span class=\"param\"><span class=\"n\">color_map</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;coolwarm&#39;</span>, </span><span class=\"param\"><span class=\"n\">show_title</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.ZernPol.gen_zernikes_surface", "modulename": "zernpy.zernikepol", "qualname": "ZernPol.gen_zernikes_surface", "kind": "function", "doc": "<p>Generate surface of provided Zernike polynomials on the generated polar coordinates used steps.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>coefficients</strong> (list):\nCoefficients of Zernike polynomials for summing.</li>\n<li><strong>polynomials</strong> (list):\nInitialized polynomials as class instances of ZernPol class specified in this module.</li>\n<li><p><strong>r_step</strong> (float, optional):\nStep for generation the vector with radiuses for an entire unit circle. The default is 0.01. </p>\n\n<p>See also the documentation for the method gen_polar_coordinates().</p></li>\n<li><p><strong>theta_rad_step</strong> (float, optional):\nStep for generation the vector with theta angles for an entire unit circle. The default is (np.pi/180). </p>\n\n<p>See also the documentation for the method gen_polar_coordinates().</p></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>zernikes_surface</strong>: namedtuple(\"ZernikesSurface\", \"ZernSurf R Theta\") - tuple for storing mesh values for polar coordinates.\nZernSurf variable is 2D matrix with the sum of the input polynomials on generated polar coordinates (R, Theta).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">coefficients</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">polynomials</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">r_step</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">theta_rad_step</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0174533</span></span><span class=\"return-annotation\">) -> <span class=\"n\">zernpy</span><span class=\"o\">.</span><span class=\"n\">zernikepol</span><span class=\"o\">.</span><span class=\"n\">ZernikesSurface</span>:</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.ZernPol.plot_sum_zernikes_on_fig", "modulename": "zernpy.zernikepol", "qualname": "ZernPol.plot_sum_zernikes_on_fig", "kind": "function", "doc": "<p>Plot a sum of the specified Zernike polynomials by input lists (see function parameters) on the provided figure.</p>\n\n<p>Note that for showing the plotted figure, one needs to call appropriate functions (e.g., matplotlib.pyplot.show()\nor figure.show()) as the method of the input parameter figure.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>coefficients</strong> (list):\nCoefficients of Zernike polynomials for summing.</li>\n<li><strong>polynomials</strong> (list):\nInitialized polynomials as class instances of ZernPol class specified in this module.</li>\n<li><strong>figure</strong> (plt.Figure):\nFigure() class there the plotting will be done, previous plot will be cleared.</li>\n<li><strong>use_defaults</strong> (bool, optional):\nUse for plotting default values for generation of a mesh of polar coordinates and calculation\nof Zernike polynomials sum. The default is True.</li>\n<li><strong>zernikes_sum_surface</strong> (namedtuple(\"ZernikesSurface\", \"ZernSurf R Theta\") , optional):\nThis tuple should contain the ZernSurf calculated on a mesh of polar coordinates R, Theta.\nThis tuple could be generated by the call of the static method gen_zernikes_surface().\nCheck the method signature for details. The default is ().</li>\n<li><strong>show_range</strong> (bool, optional):\nFlag for showing range of provided values as the colorbar on the figure. The default is True.</li>\n<li><strong>color_map</strong> (str, optional):\nColor map of the polar plot, recommended values: coolwarm, jet, turbo, rainbow. The default is \"coolwarm\".</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: Check the signature for details. In general, it will be raised if some input parameters are inconsistent.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>figure</strong> (plt.Figure):\nMatplotlib.pyplot Figure class there the Zernike polynomials sum plotted.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">coefficients</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">polynomials</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">figure</span><span class=\"p\">:</span> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">figure</span><span class=\"o\">.</span><span class=\"n\">Figure</span>,</span><span class=\"param\">\t<span class=\"n\">use_defaults</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">zernikes_sum_surface</span><span class=\"p\">:</span> <span class=\"n\">zernpy</span><span class=\"o\">.</span><span class=\"n\">zernikepol</span><span class=\"o\">.</span><span class=\"n\">ZernikesSurface</span> <span class=\"o\">=</span> <span class=\"p\">()</span>,</span><span class=\"param\">\t<span class=\"n\">show_range</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">color_map</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;coolwarm&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">figure</span><span class=\"o\">.</span><span class=\"n\">Figure</span>:</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.generate_polynomials", "modulename": "zernpy.zernikepol", "qualname": "generate_polynomials", "kind": "function", "doc": "<p>Generate tuple with ZernPol instances (ultimately, representing Zernike polynomials) indexed using OSA scheme.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>max_order</strong> (int, optional):\nMaximum overall radial order (n) for generated Zernike list (pyramid). The default is 10.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: Raised if max_order &lt; 1, because it should be not less than 0.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tuple</strong>: It composes generated ZernPol instances (Zernike polynomials) ordered using OSA indexing scheme.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">max_order</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">10</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.generate_random_phases", "modulename": "zernpy.zernikepol", "qualname": "generate_random_phases", "kind": "function", "doc": "<p>Generate phases image (profile) for random set of polynomials with randomly selected amplitudes.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>max_order</strong> (int, optional):\nMaximum radial order of generated Zernike polynomials. The default is 4.</li>\n<li><strong>img_width</strong> (int, optional):\nWidth of generated image. The default is 513.</li>\n<li><strong>img_height</strong> (int, optional):\nHeight of generated image. The default is 513.</li>\n<li><strong>round_digits</strong> (int, optional):\nRound digits for polynomials amplitudes generation (numpy.round(...) function call). The default is 4.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tuple</strong>: Consisting of:\n2D phase profile image with provided width and height;\n1D numpy.ndarray containing randomly selected polynomials amplitudes;\ntuple with generated Zernike polynomials.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">max_order</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">4</span>,</span><span class=\"param\">\t<span class=\"n\">img_width</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">513</span>,</span><span class=\"param\">\t<span class=\"n\">img_height</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">513</span>,</span><span class=\"param\">\t<span class=\"n\">round_digits</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">4</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.fit_polynomials", "modulename": "zernpy.zernikepol", "qualname": "fit_polynomials", "kind": "function", "doc": "<p>Fit provided Zernike polynomials (instances of ZernPol class) as the input tuple to the 2D phase image.</p>\n\n<p>Note that Piston (Z(0, 0) polynomial) is ignored and not fitted, because it represents the constant phase offset\nover a unit aperture (pupil).\nAlso, 2D phase image implies that phases recorded depending on cartesian coordinates and circle aperture is cropped\nout from this image for fitting procedure. One can check the result of cropping by plotting return_cropped_image as\nTrue and plotting the second item from the returned tuple.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>phases_image</strong> (numpy.ndarray):\n2D image with recorded phases which should be approximated by the sum of Zernike polynomials.\nNote that image is assumed as the recorded phases on the cartesian coordinates. The circle\n(aperture) containing phases is cropped from the input image during the fitting procedure.</li>\n<li><strong>polynomials</strong> (tuple):\nInitialized tuple with instances of the ZernPol class that effectively represents target set of Zernike polynomials.</li>\n<li><strong>crop_radius</strong> (float, optional):\nAllow cropping pixel from range [0.5, 1.0], where 1.0 corresponds to radius of the cropped circle = min image size.\nThe default is 1.0.</li>\n<li><strong>suppress_warnings</strong> (bool, optional):\nFlag for suppress warnings about the provided 2D image sizes. The default is False.</li>\n<li><strong>strict_circle_border</strong> (bool, optional):\nFlag for controlling how the border pixels (on the circle radius) are treated: strictly or less strict for\nallowing more pixels to be treated as belonged to a cropped circle. The default is False.</li>\n<li><strong>round_digits</strong> (int, optional):\nRound digits for returned polynomials amplitudes (numpy.round(...) function call). The default is 4.</li>\n<li><strong>return_cropped_image</strong> (bool, optional):\nFlag for calculating and returning cropped image, used for fitting procedure. The default is False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tuple</strong>: Depending on the input parameter (flag) \"return_cropped_image\":\nif it is True, then tuple returned with following variables: zernike_coefficients - 1D numpy.ndarray\nwith the fitted coefficients of Zernike polynomials, and cropped_image - the cropped part from the\ninput image with phases that is used for fitting procedure (useful for debugging purposes);\nif it is False, the following tuple will be returned: zernike_coefficients, None - 1st with the same\nmeaning and type as explained before.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">phases_image</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">polynomials</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>,</span><span class=\"param\">\t<span class=\"n\">crop_radius</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">suppress_warnings</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">strict_circle_border</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">round_digits</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">4</span>,</span><span class=\"param\">\t<span class=\"n\">return_cropped_image</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.fit_polynomials_vectors", "modulename": "zernpy.zernikepol", "qualname": "fit_polynomials_vectors", "kind": "function", "doc": "<p>Fit provided Zernike polynomials (instances of ZernPol class) as the input tuple to the provided 1D vectors.</p>\n\n<p>1D vectors should contain: phases recorded in the related radii and thetas (polar coordinates). For the example\nof phases and coordinates composing, see the module test_fitting in 'tests' sub-folder of the repository.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>polynomials</strong> (tuple):\nInitialized tuple with instances of the ZernPol class that effectively represents target set of Zernike polynomials.</li>\n<li><strong>phases_vector</strong> (numpy.ndarray):\nRecorded phases.</li>\n<li><strong>radii_vector</strong> (numpy.ndarray):\nRelated radii - 1st polar coordinates for the recorded phases.</li>\n<li><strong>thetas_vector</strong> (numpy.ndarray):\nRelated angles (thetas) - 2nd polar coordinates for the recorded phases.</li>\n<li><strong>round_digits</strong> (int, optional):\nRound digits for returned polynomials amplitudes (numpy.round(...) function call). The default is 4.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>AttributeError</strong>: The any of provided vectors (phases_vector, etc.) isn't proper 1D numpy.ndarray (len(array.shape &gt; 1).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>zernike_coefficients</strong> (numpy.ndarray):\n1D numpy.ndarray with the fitted coefficients of Zernike polynomials.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">polynomials</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>,</span><span class=\"param\">\t<span class=\"n\">phases_vector</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">radii_vector</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">thetas_vector</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">round_digits</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">4</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.compare_performances", "modulename": "zernpy.zernikepol", "qualname": "compare_performances", "kind": "function", "doc": "<p>Compare performances of radial polynomials calculation by using recursive and exact equations.</p>\n\n<p>Comparison achieved by simple measuring of time in msec needed for calculation of all radial\npolynomials from minimal radial order up to maximum radial order returned as tuple.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>min_order</strong> (int):\nMinimum radial order of used polynomials (n).</li>\n<li><strong>max_order</strong> (int):\nMaximum radial order of used polynomials (n).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tuple</strong>: Composed by time for recursive calculation and time for exact calculation.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">min_order</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">max_order</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "zernpy.zernikepol.check_conformity", "modulename": "zernpy.zernikepol", "qualname": "check_conformity", "kind": "function", "doc": "<p>Test initialization parameters and transform between indices consistency.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None.</strong></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();